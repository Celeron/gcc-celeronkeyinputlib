#ifndef CELERON_KEYINPUTLIB_H
#define CELERON_KEYINPUTLIB_H

//---------------------------------------------------------------------------
//
// Настройка библиотеки
//
//---------------------------------------------------------------------------


// Настройка Интегратора (функция математического подавления звона и помех):
//    (Примечание: данные константы используются в процедуре keyScanInput_SystickHandler, использующей метод периодического опроса состояния Портов.)
//    Задайте "глубину защёлки" интегратора, для каналов Кнопок и Энкодеров - что аналогично подстройке "постоянной времени" помехоподавляющей RC-цепи...
//    Физический смысл констант: кнопка должна удерживаться непрерывно, в течение, как минимум, LatchDepth миллисекунд, чтобы зафиксировалось изменение ее состояния (переход из "нажатой" в "отпущенную", или наоборот).
//    Допустимые значения констант = [1..128] мс
//    Рекомендация: нельзя делать значения этих констант слишком большими, иначе можно получить ситуацию "тормозного отклика" на нажатия, или возможно даже, что нажатия кнопок или поворот энкодера перестанут фиксироваться вообще.
//    Особенность: чтобы отключить функцию "интеграции каналов" и программную защиту от помех (на случай, если вы распаяли внешние аппаратные помехоподавляющие RC-цепочки на ваших кнопках?) - следует установить значение соответствующей "защелки" в единицу (LatchDepth=1). Подчеркиваю: не в ноль, и не закомментировать - но макроопределение должно быть задано, и равно единице!
#define CButtonLatchDepth   20    /* глубина защёлки интегратора, для опроса тактовых Кнопок = количество циклов опроса, в течение которых кнопка должна возвращать статус "1", чтобы посчитаться "нажатой" или "0", чтобы посчитаться "отпущенной". */

//    Рекомендация: для Энкодеров, глубина защелки интегратора должна быть вообще маленькой, поскольку им обычно требуется до четырех переключений каналов на один тик/пульс/шаг, при 24 тиках на оборот! Что довольно часто, и требует динамичного отклика сканирующей системы...
//    Важная особенность: чтобы отключить обработку Энкодеров через keyScanInput_SystickHandler (на случай, если вы обрабатываете Энкодеры методом keyScanInput_EXTIHandler) - не задавайте значение константе CEncoderLatchDepth, а просто закомментируйте данное макроопределение. Подчеркиваю: это работает только для Энкодеров (обработку Кнопок так нельзя отключить).
//#define CEncoderLatchDepth  2     /* глубина защёлки интегратора, для опроса контактных групп Энкодера... в целом, то же, что и для обычных тактовых кнопок, но для Энкодера - "глубина защёлки" задаётся отдельно и на порядок меньше! Поскольку контакты Энкодера более стабильны и помехоустойчивы, а кроме того, Энкодер переключается ГОРАЗДО чаще, чем тактовые Кнопки. */



// Частота запуска обработчика keyScanInput_SystickHandler (в Герцах)
// Примеры: 
//    Опрос кнопок с интервалом 1мс   - соответствует Частоте 1000 Гц. (рекомендуется)
//    Опрос кнопок с интервалом 10мс  - соответствует Частоте  100 Гц. (допустимо, если Интегратор отключён)
//    Опрос кнопок с интервалом 100мс - соответствует Частоте   10 Гц. (не рекомендуется по соображениям эргономики управления, слишком инертная реакция на кнопки)
#define CButtonSystickFrequency  1000

// Частота дискретизации времени (в Герцах), с которой наращивается "счетчик времени удержания" в статус-регистре Кнопки.
//    Примечание: емкость 5-битного "счетчика времени удержания" = 31 дискретной единице. Но фактическое время - зависит от частоты дискретизации!
//    Максимальное учитываемое фактическое время, в секундах = (2^5-1)/CButtonTimeIncFrequency.
//    Например: при Частоте=2 Гц, фиксируется время удержания до 15,5 сек... а при Частоте=4 Гц, фиксируется Время до 7,75 сек.
#define CButtonTimeIncFrequency  8

// Настройка порога "времени удержания" (в дискретных единицах счетчика), по достижении которого для Кнопки уже фиксируется статус-код "BSC_LongHold".
//    (Примечание: данная константа используется в процедуре keyIncreaseTimeForAllButtons.)
//    Итак, задайте максимальное время удержания кнопки (количество полных дискретных единиц времени: по 1/CButtonTimeIncFrequency сек), ДО прошествия которого ещё фиксируется статус-код "ShortHold", а СВЫШЕ ИЛИ РАВНО - уже считается "LongHold"...
//    Например: чтобы "LongHold" считался при 1.5 сек и выше, следует задать значение (1.5 сек)/(1/CButtonTimeIncFrequency) = (1.5 сек)*CButtonTimeIncFrequency.
#define CButtonLongHoldDuration  ((uint8_t)((CButtonTimeIncFrequency)*(1.25)))



// Включить функцию "Smart Button" (требует чуть больше ресурсов) (чтобы выключить - закомментируйте)
//    Позволяет реализовать, например, рецепт: как двумя кнопками "больше/меньше" организовать эргономичный интерфейс подстройки некоторого параметра: 
//    "пользователь нажал кнопку и удерживает — после секундной паузы, значение начинает автоматически набегать +1, +1,... а через некоторое время, начинает набегать быстрее +5, +5,..."
#define SMART_BUTTON_ENABLE

// Полностью отключить обработку Энкодеров данной библиотекой  (чтобы отключить - раскомментируйте макроопределение)
//    Полезно, для экономии ресурсов в слабых 8-битных микроконтроллерах, если энкодеров нет в схеме (энкодеры же нечасто присутствуют в устройстве)...
//    Также, стоит отключить программную обработку (раскомментировать макрос) - если обработка Энкодеров осуществляется полностью аппаратно (в STM32 рекомендуется использовать аппаратный таймер).
#define NO_ENCODERS_AT_ALL



//---------------------------------------------------------------------------
//
// Вспомогательные Макросы
//
//---------------------------------------------------------------------------



// Проверить: Если статус-регистр STATUS хранит статус-код == VALUE ?
// Где: допустимые значения статус-кода VALUE = BSC_NotPressed, BSC_ShortHold, BSC_LongHold, BSC_ShortPress, BSC_LongPress (значение поля BUTTON_STATUS_CODE)...
//
//Низкоуровневый макрос, принимающий в качестве аргумента статусный Регистр кнопки:
#define BUTTON_REGISTER_HAVE_STATUS( STATUS, VALUE )    (((STATUS)&(0x07<<BUTTON_STATUS_CODE)) == ((VALUE)<<BUTTON_STATUS_CODE))
//Прикладной макрос, принимающий в качестве аргумента Идентификатор кнопки:
#define BUTTON_HAVE_STATUS( ID, VALUE )                 BUTTON_REGISTER_HAVE_STATUS( keyButtonList[(ID)].Status, VALUE )



// Проверить: Если в статус-регистре STATUS установлен флаг & FLAG ?
// Где: допустимые значения флага FLAG = BUTTON_IS_HOLDDOWN, BUTTON_IS_PRESSED, BUTTON_HOLDEN_LONG (т.е. отдельные составляющие трехбитного кода BUTTON_STATUS_CODE)...
// Особенности применения:
//    Данный макрос можно применять вместо серии макросов BUTTON_HAVE_STATUS, для тестирования отдельных составляющих статус-кода. Обычно, он используется для проверки "удерживается ли в данный момент кнопка?" (и не важно сколько времени):
//      Таким образом, например, вместо избыточной пары выражений:  if(BUTTON_HAVE_STATUS(BSC_ShortHold) || BUTTON_HAVE_STATUS(BSC_LongHold))... достаточно одного:  if(BUTTON_HAVE_FLAG(BUTTON_IS_HOLDDOWN))...
//      Аналогично, и для тестирования факта совершенного полного нажатия+отпускания, вне зависимости от того сколько кнопка удерживалась:  if(BUTTON_HAVE_STATUS(BSC_ShortPress) || BUTTON_HAVE_STATUS(BSC_LongPress))... заменяется на один:  if(BUTTON_HAVE_FLAG(BUTTON_IS_PRESSED))...
//    Причем, в этом макросе включена проверка "статуса" на "отложенный сброс"! Таким образом, "сброшенные" кнопки игнорируются - для них, данный макрос всегда возвращает FALSE.
//
//Низкоуровневый макрос, принимающий в качестве аргумента статусный Регистр кнопки:
#define BUTTON_REGISTER_HAVE_FLAG( STATUS, FLAG )       (((STATUS)!=(RESET_BUTTON_STATUS)) && ((STATUS)&(1<<(FLAG))))
//Прикладной макрос, принимающий в качестве аргумента Идентификатор кнопки:
#define BUTTON_HAVE_FLAG( ID, FLAG )                    BUTTON_REGISTER_HAVE_FLAG( keyButtonList[(ID)].Status, FLAG )



// Проверить: в течение какого времени удерживается кнопка? Точнее, удерживается (или удерживалась) ли кнопка "нажатой" в течение TIME миллисекунд ИЛИ ДОЛЬШЕ ?
// Где: 
//    TIME указывается в мс, для удобства человеческого восприятия, и чтобы исключить вещественные значения в прикладном коде.
//    Допустимые значения параметра TIME = [1*CButtonSystickFrequency/CButtonTimeIncFrequency .. (2^5-1)*CButtonSystickFrequency/CButtonTimeIncFrequency]  (сравниваются со значением пятибитного поля BUTTON_HOLDING_TIME).
//      Но следует помнить, что в статус-регистре время наращивается дискретно, с частотой CButtonTimeIncFrequency (и в пределах кванта - время не дифференцируется)!
//      Еще замечу, что спрашивать TIME=0 нет смысла - т.к. даже если кнопка вообще не нажималась, то формально, она однозначно "удерживается от 0 или больше мс"...
//      И также, время меньше учетного порога (TIME < CButtonSystickFrequency/CButtonTimeIncFrequency) приравнивается к TIME=0.
// Особенности применения:
//    Данный макрос следует использовать в связке с макросом проверки текущего состояния кнопки: 
//      if(BUTTON_HAVE_STATUS(удерживается или нажата) && BUTTON_HAVE_TIME(уже такое-то время))...
//      if(BUTTON_HAVE_FLAG(удерживается или нажата)   && BUTTON_HAVE_TIME(уже такое-то время))...
//      Это логично, поскольку если проверять только время, то "время чего" мы узнаем? Время удержания в данный момент? Или время которое кнопка удерживалась когда-то?..
//      А ведь обработчики событий пишутся так, чтобы срабатывать на событие в актуальный момент времени, когда событие происходит - поэтому они всегда включают проверку текущего состояния кнопки.
//    Также, в этом макросе включена проверка "статуса" на "отложенный сброс"! Таким образом, "сброшенные" кнопки игнорируются - для них, данный макрос всегда будет возвращать FALSE.
//
//Низкоуровневый макрос, принимающий в качестве аргумента статусный Регистр кнопки:
#define BUTTON_REGISTER_HAVE_TIME( STATUS, TIME )       (((STATUS)!=(RESET_BUTTON_STATUS)) && (((STATUS)&(0x1F<<BUTTON_HOLDING_TIME)) >= (((CButtonTimeIncFrequency)*(TIME)/(CButtonSystickFrequency))<<BUTTON_HOLDING_TIME)))
//Прикладной макрос, принимающий в качестве аргумента Идентификатор кнопки:
#define BUTTON_HAVE_TIME( ID, TIME )                    BUTTON_REGISTER_HAVE_TIME( keyButtonList[(ID)].Status, TIME )



// Переключить Статус Кнопки в состояние "ОТЛОЖЕННЫЙ СБРОС".
//    Применение особого промежуточного статуса "отложенный сброс" позволяет подавлять для кнопок нежелательные серийные реакции. (Это как отключение "повтора вводимого символа" для компьютерной клавиатуры...)
//    Например, обычно от кнопки ожидается однократная реакция на нажатие. Затем, пользователь должен отпустить кнопку. И только при повторном нажатии кнопки - следует повторно запускать прикладную функцию...
// Особенности применения:
//    Вызывается по завершению обработки события связанного с Кнопкой.
//    Статусный регистр Кнопки будет ОБНУЛЕН автоматически (проинициализирован в исходное состояние), как только физическая кнопка будет отпущена.
#define BUTTON_RESET( ID )                              (keyButtonList[(ID)].Status = RESET_BUTTON_STATUS)



// Состояние "отложенный сброс" имеет важную особенность: оно СОХРАНЯЕТСЯ для Кнопки до тех пор, пока физическая кнопка не будет ОТПУЩЕНА. А затем, при отпускании кнопки, статус-регистр кнопки сбрасывается в ноль АВТОМАТИЧЕСКИ.
// Второй важной особенностью является значение хранимое в статус-регистре, в состоянии "отложенный сброс" - все биты УСТАНОВЛЕНЫ в единицы.
// Эти два факта вместе позволяют применить один хитрый, но полезный, сценарий тестирования кнопок...
//
// Узкоспециализированный макрос BUTTON_HOLDDOWN_OR_RESET срабатывает на события "кнопка удерживается" или "кнопка сброшена".
//    (Примечание: данный макрос является модификацией рассмотренного выше BUTTON_HAVE_FLAG. Разница в том, что в здесь умышленно пропущена проверка "статуса" на "отложенный сброс". А также, из всех флагов, этот макрос реагирует только на "удержание" кнопки.)
//    Таким образом, данный макрос будет возвращать TRUE - для всё еще "удерживаемых", но уже обработанных и "сброшенных" кнопок. 
//    Ну, и для не сброшенных удерживаемых кнопок - тоже сработает (вернет TRUE), что важно.
//
// Описание проблемы:
//    Обычно, для нажатых кнопок нужно подавлять серийные реакции: одно нажатие - одна отработка, затем СБРОС, и блокировка до отпускания физической кнопки...
//    Но предположим, есть кнопка "модификатор поведения": пока кнопка удерживается, другие кнопки функционируют иначе... Для таких кнопок - обычно, просто не применяется СБРОС, а обработчик вешается только на флаг BUTTON_IS_HOLDDOWN...
//    Но пойдем дальше: пусть некая кнопка работает и как модификатор (в составе аккорда), и как полноценная одиночная кнопка (когда другие модификаторы не удерживаются)!
//    В последнем случае, есть момент: когда кнопка отработала как модификатор, ее отпускают, и...
//      Если не сбросить её статус, то она преобразуется в статус BUTTON_IS_PRESSED, на который могут ложно отреагировать другие обработчики!
//      Кроме того, разваливается аккорд, в котором была задействована данная кнопка, и все другие кнопки аккорда внезапно проявляются в системе, как "нормально нажатые", на которые может среагировать ещё куча других обработчиков!
// Решение:
//    Вот в таких случаях, полезно вешать обработчик аккорда на условие с макросами BUTTON_HOLDDOWN_OR_RESET, а в обработчике сбрасывать статусы всех входящих кнопок!
//
// Пример:
//    Пусть, в вашем устройстве есть только две кнопки: кнопка1="вращать мотор влево" и кнопка2="вращать мотор вправо".
//    При отпускании соответствующей кнопки - мотор останавливается. Т.е. обработчик каждой отдельной кнопки следует повесить на событие BUTTON_IS_HOLDDOWN, и в обработчике не сбрасывать статус-регистр...
//    Но тут, внезапно, требуется запрограммировать еще третью функцию: "вращение с удвоенной скоростью" - она будет срабатывать при одновременном удержании обоих кнопок. 
//    Причем, нужно подавить побочный эффект при отпускании такого аккорда из двух кнопок: мотор должен просто остановиться, без глюков, без дерганий влево-вправо!
// Пишем так:
//
//    while(1) 
//    {
//      static Скорость=0;
//
//      if(BUTTON_HOLDDOWN_OR_RESET(кнопка1) && BUTTON_HOLDDOWN_OR_RESET(кнопка2))
//      { //Этот обработчик будет вызываться многократно, пока зажаты обе кнопки, не взирая на сброс их статусов
//        Повернуть(Скорость*2);
//        BUTTON_RESET(кнопка1);    //Предотвращаем побочные эффекты при отпускании Кнопок...
//        BUTTON_RESET(кнопка2);
//      }
//
//      if(BUTTON_HAVE_FLAG(кнопка1, BUTTON_IS_HOLDDOWN))
//      { //Этот обработчик перестанет стартовать, после сброса статуса кнопки
//        Скорость = +1;
//        Повернуть(Скорость);
//      }
//
//      if(BUTTON_HAVE_FLAG(кнопка2, BUTTON_IS_HOLDDOWN))
//      { //Этот обработчик перестанет стартовать, после сброса статуса кнопки
//        Скорость = -1;
//        Повернуть(Скорость);
//      }
//    }
//
//Низкоуровневый макрос, принимающий в качестве аргумента статусный Регистр кнопки:
#define BUTTON_REGISTER_HOLDDOWN_OR_RESET( STATUS )     ((STATUS)&(1<<(BUTTON_IS_HOLDDOWN)))
//Прикладной макрос, принимающий в качестве аргумента Идентификатор кнопки:
#define BUTTON_HOLDDOWN_OR_RESET( ID )                  BUTTON_REGISTER_HOLDDOWN_OR_RESET( keyButtonList[(ID)].Status )



//---------------------------



// Получить количество тиков, накопленное в "счетном регистре" Энкодера
#define ENCODER_COUNTER( ID )              (keyEncoderList[(ID)].Counter)


// Обнулить "счетный регистр" Энкодера (следует применять по завершению обработки события связанного с Энкодером)
#define ENCODER_RESET( ID )                (ENCODER_COUNTER(ID) = 0)



//---------------------------



// Определение Кнопки в системе
#ifdef STM32F103xE
#define DECLARE_BUTTON(GPIO_, PIN_) {  \
    .Channel.GPIO = GPIO_,             \
    .Channel.Pin  = PIN_,              \
    .Integrator = 0,                   \
    .Status = 0}
#endif
#ifdef __XC8
#define DECLARE_BUTTON(PORT_, PIN_) {  \
    /* .Channel.Port = */ PORT_,       \
    /* .Channel.Pin  = */ PIN_,        \
    /* .Integrator   = */ 0,           \
    /* .Status       = */ 0}
#endif



// Определение Энкодера в системе
#ifdef STM32F103xE
#define DECLARE_ENCODER(GPIO1,PIN1, GPIO2,PIN2) {  \
    .Channel1.GPIO = GPIO1,                        \
    .Channel1.Pin  = PIN1,                         \
    .Integrator1 = 0,                              \
    .Channel2.GPIO = GPIO2,                        \
    .Channel2.Pin  = PIN2,                         \
    .Integrator2 = 0,                              \
    .Status = 0,                                   \
    .Counter = 0}
#endif
#ifdef __XC8
#define DECLARE_ENCODER(PORT1,PIN1, PORT2,PIN2) {  \
    /* .Channel1.Port = */ PORT1,                  \
    /* .Channel1.Pin  = */ PIN1,                   \
    /* .Integrator1   = */ 0,                      \
    /* .Channel2.Port = */ PORT2,                  \
    /* .Channel2.Pin  = */ PIN2,                   \
    /* .Integrator2   = */ 0,                      \
    /* .Status        = */ 0,                      \
    /* .Counter       = */ 0}
#endif



// Стандартный вспомогательный приемчик: вычисляет количество элементов в массиве.
// См. справку по "Препроцессору Си"... http://ru-wiki.org/wiki/%D0%9F%D1%80%D0%B5%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80_%D0%A1%D0%B8
#define NUMBER_OF_ARRAY_ITEMS( array ) ( sizeof( array ) / sizeof( *(array) ) )




//---------------------------------------------------------------------------
//
// Определение Типов
//
//---------------------------------------------------------------------------
// Программисту, важное замечание: Все базовые типы данных должны иметь размер 1 байт - 
// чтобы на 8-битных микроконтроллерах приложение было "thread-safe" (обеспечить атомарный доступ к памяти).


//---------------------------
// Входной канал
//---------------------------

// Определение типа для данных, описывающих "Входной канал" 
// Примечание: в данной реализации - это некий Порт, на котором висит кнопка... Но теоретически, можно переделать код (метод keyScanInput) и для другой реализации: опрос клавиатурной матрицы, через АЦП, или др.
typedef struct {
#ifdef STM32F103xE
  GPIO_TypeDef*      GPIO;  // Порт = (GPIOA, GPIOB,...)
  uint16_t           Pin;   // Пин  = [GPIO_PIN_0 .. GPIO_PIN_15]
#endif
#ifdef __XC8
  volatile uint8_t*  Port;  // Порт = (&PORTA, &PORTB,...)
  uint8_t            Pin;   // Пин  = [0..7]
#endif
} TInputChannel;



//---------------------------
// Регистр Интегратора
//---------------------------

// Определение типа для регистра "Интегратор"
typedef volatile int8_t TInputIntegrator;     // памятка: int8_t = signed char

// Расшифровка структуры регистра "Интегратор"
#define INTEGRATOR_IS_PRESSED   7   /* Флаг "интегральное состояние канала" (он же Negative Flag "N"), означает: ="0" (кнопка отпущена) или ="1" (кнопка нажата). */



//---------------------------
// Регистры данных Кнопки
//---------------------------

// Определение типа для регистра "Статус Кнопки"
typedef volatile uint8_t TButtonStatus;

// Определение типа для счетчика времени
typedef volatile uint8_t TButtonSmartTimer;


// Расшифровка структуры регистра "Статус Кнопки"
#define BUTTON_HOLDING_TIME   0    /* Пять битов   [4:0] = счётчик количества дискретных единиц времени (по 1/CButtonTimeIncFrequency сек), в течение которых Кнопка удержива(лась/ется) "нажатой". */
#define BUTTON_STATUS_CODE    5    /* В трёх битах [7:5] = кодируется итоговый "статус-код кнопки" (см. ниже макроопределения констант). */
#define BUTTON_HOLDEN_LONG    5    /* Флаг "длительность удержания кнопки": 0-короткое или 1-длинное. */
#define BUTTON_IS_PRESSED     6    /* Флаг "зафиксировано полноценное нажатие кнопки": "0" - кнопка не нажималась, "1" - было нажатие. */
#define BUTTON_IS_HOLDDOWN    7    /* Флаг "кнопка удерживается в нажатом состоянии": "0" - сейчас кнопка "отпущена", "1" - сейчас кнопка "нажата и удерживается". */


// Возможные значения поля BUTTON_STATUS_CODE           (полагаю, для описания большинства распространённых "жестов" с кнопками - хватит 4 ситуации):
#define BSC_NotPressed        0    /*  0b000 = "не нажата"          (исходное положение для всех кнопок - бывает только после "сброса") */
#define BSC_ShortHold         4    /*  0b100 = "короткое удержание" (кнопка нажата, и всё ещё удерживается, пока "короткое" время) */
#define BSC_LongHold          5    /*  0b101 = "длинное удержание"  (кнопка нажата, и всё ещё удерживается, уже "длительное" время) */
#define BSC_ShortPress        2    /*  0b010 = "короткое нажатие"   (кнопка была нажата, и затем отпущена, а время её удержания было "незначительным") */
#define BSC_LongPress         3    /*  0b011 = "длинное нажатие"    (кнопка была нажата, и затем отпущена, а время её удержания было "длительным") */
#define BSC_ResetStatus       7    /*  0b111 = "отложенный сброс"   (кнопка находится в спец.состоянии "отложенный сброс") */
// Примечание: здесь, префикс "BSC_" означает "Button Status Codes"...


// Код "ОТЛОЖЕННЫЙ СБРОС" (0b11111111), который следует присвоить статус-регистру Кнопки, по завершению обработки связанного с ней события  (для сброса статус-регистра в начальное положение и готовности реагировать на новые события)
#define RESET_BUTTON_STATUS   0xFF



// Данные описывающие конкретную Кнопку
typedef struct {
  TInputChannel      Channel;
  TInputIntegrator   Integrator;
  TButtonStatus      Status;        // регистр "Статус Кнопки"
#ifdef SMART_BUTTON_ENABLE
  TButtonSmartTimer  SmartTimer;    // счетчик времени, прошедшего с момента последнего сканирования "умного статуса" (наращивается с частотой CButtonTimeIncFrequency)
#endif
} TButtonData;



//---------------------------
// Регистры данных Энкодера
//---------------------------

// Определение типа для регистра "Статус Энкодера"
// Примечание: статус-регистр энкодера, напрямую, никогда не используется прикладным кодом!
typedef volatile uint8_t TEncoderStatus;

// Определение типа для регистра "Счётчик тиков"  
// Формат счётчика: особой специальной структуры не содержит. Это просто знаковое целое число: Signed Int = [-128..127]
typedef volatile int8_t TEncoderCounter;     // памятка: int8_t = signed char


// Расшифровка структуры регистра "Статус Энкодера" (первый из пары, выше)
#define ENCODER_STATUS_X1           0    /* Предыдущее        состояние энкодера: значение входного канала AC(X1) */
#define ENCODER_STATUS_Y1           1    /* Предыдущее        состояние энкодера: значение входного канала BC(Y1) */
#define ENCODER_STATUS_PRECOUNTER   2    /* Следующие два бита - это предварительный счётчик =1..4, через который "по 4 переключения входных сигналов на один тик" преобразуются к фактическому числу тиков, накапливаемому в регистре "счётчика тиков" энкодера... */
#define ENCODER_STATUS_X2           4    /* Последнее/текущее состояние энкодера: значение входного канала AC(X2) */
#define ENCODER_STATUS_Y2           5    /* Последнее/текущее состояние энкодера: значение входного канала BC(Y2) */
#define ENCODER_STATUS_F2           7    /* Последнее/текущее состояние энкодера: вычисленное направление вращения (F2) - это самая нужная, итоговая статусная информация: в какую сторону осуществлён последний тик поворота? */
// Кодировка:
// 	F = 0	C.W., 	вращение по часовой ("правый винт")	(+1) к счётчику
// 	F = 1	C.C.W.,	вращение против часовой ("левый винт")	(-1) к счётчику
// 	кодировка входных каналов X,Y (=0 или 1), здесь, в принципе, не важна - используется лишь порядок их переключения...



// Данные описывающие конкретный Энкодер
typedef struct {
  TInputChannel    Channel1;
  TInputIntegrator Integrator1;
  TInputChannel    Channel2;
  TInputIntegrator Integrator2;
  TEncoderStatus   Status;        // регистр "Статус Энкодера" (напрямую прикладный кодом не используется!)
  TEncoderCounter  Counter;       // регистр "Счётчик тиков"
} TEncoderData;




//---------------------------------------------------------------------------
//
// Декларация Данных
//
//---------------------------------------------------------------------------


// Коллекция всех подключенных Кнопок
extern TButtonData   keyButtonList[];
extern uint8_t       keyButtonListCount;


// Коллекция всех подключенных Энкодеров
extern TEncoderData  keyEncoderList[];
extern uint8_t       keyEncoderListCount;


// Идентификаторы Кнопок (порядковый номер в коллекции keyButtonList):
#define BUTTON_ENCODER          0    /* PD13 - Button: Encoder  (кнопка встроенная в вал энкодера) */
#define BUTTON_MENU_PREV        1    /* PD10 - Button: MenuPrev (верхнее меню) */
#define BUTTON_MENU_OK          2    /* PD9  - Button: MenuOk   (верхнее меню) */
#define BUTTON_MENU_NEXT        3    /* PD8  - Button: MenuNext (верхнее меню) */
#define BUTTON_ESCAPE           4    /* PB15 - Button: Escape   (отменить/СТОП) */
#define BUTTON_ENTER            5    /* PB13 - Button: Enter    (сохранить/ПУСК) */


// Идентификаторы Энкодеров (порядковый номер в коллекции keyEncoderList):
#define ENCODER_INTERNAL        0    /* Примечание: Сейчас, Энкодер подключен через аппаратный таймер "Timer5". И данной библиотекой не обрабатывается! */
#define ENCODER_EXTERNAL        1    /* Примечание: Сейчас, Энкодер подключен через аппаратный таймер "Timer8". И данной библиотекой не обрабатывается! */




//---------------------------------------------------------------------------
//
// Прототипы Методов
//
//---------------------------------------------------------------------------


//-------------------------------------
// Подключение бибилиотеки
//-------------------------------------

// Головная процедура запуска конвеера обработки: для Кнопок и Энкодеров.
// Ее вызов следует поместить в обработчик прерывания SysTick_Handler()...
void keyScanInput_SystickHandler(void);

// Головная процедура запуска конвеера обработки: ТОЛЬКО ДЛЯ ЭНКОДЕРОВ, альтернативный метод (быстрее).
// Ее вызов следует поместить в обработчик прерывания EXTI_IRQHandler()...
// Настройка аппаратной части: для обоих каналов Энкодера, переключить порты в функцию GPIO_EXTI, включить Прерывание, режим "on Rising/Falling edge"...
// Важно: если вы используете также метод keyScanInput_SystickHandler, то чтобы не было конфликтов, обязательно закомментируйте определение константы CEncoderLatchDepth! Тогда автоматически отключится обработка Энкодеров в обработчике keyScanInput_SystickHandler...
void keyScanInput_EXTIHandler(void);



//-------------------------------------
// Прикладные методы
//-------------------------------------

// Вспомогательные методы обработки статусов кнопок:
void    keyResetStatusForAllButtons(void);
uint8_t keyIfAnyButtonUnhandled(void);
uint8_t keyIfAnyButtonHolddown(void);
uint8_t keyIfSmartButtonPressed(uint8_t ID, uint8_t WaitingScheme);


// Для обратной совместимости (obsolete)
#define keyIfAnyButtonPressed keyIfAnyButtonUnhandled
#define keyIfAnyButtonHolding keyIfAnyButtonHolddown



#endif  // CELERON_KEYINPUTLIB_H
