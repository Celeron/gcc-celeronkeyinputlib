/******************************************************************************
 * Модуль:      celeronkeyinputlib.c  (MiddleWare)  v1.1
 * Автор:       Celeron  http://inventproject.info/
 * Назначение:  Библиотека процедур для интеллектуальной обработки ВВОДА: сканирование Кнопок и Энкодеров.
 ******************************************************************************/


//   КАК ПОДКЛЮЧИТЬ БИБЛИОТЕКУ (СПРАВКА)
//
// Приведенные здесь процедуры являются универсальными, их код модифицировать [обычно] не требуется!
// Единственная процедура в этой библиотеке, код которой ВОЗМОЖНО прийдется адаптировать к вашей конкретной физической схеме - это keyScanChannel (через которую осуществляется связь с физическими каналами ввода).
// Однако, стандартная реализация функции сканирования физических каналов - тоже хороша: предназначена для обработки Кнопок/Энкодеров, подключенных непосредственно к портам микроконтроллера, между портом и землей, без мультиплексирования (стандартный случай).
// Если же потребуется изменить и усложнить реализацию (например, запрограммировать поддержку клавиатуры на резистивных делителях?), то вам придется также изменить базовый тип TInputChannel: для внесения в него уточняющих данных по физической реализации канала, чтобы потом использовать эти данные в коде функции keyScanChannel.
//
// Также, под вашу конкретную физическую схему, требуется "определить данные" для всех подключенных физических Кнопок и Энкодеров, которые будут обрабатываться данной библиотекой (см. ниже раздел "Определение Данных").
// И также, можно подстроить значения некоторых служебных констант в заголовочном файле "celeronkeyinputlib.h"...
//
// Еще требуется поместить вызовы "Головных процедур запуска конвеера обработки" (это callbackи) в Прерывания, чтобы они запускались с заданной периодичностью, автоматически (рекомендуемый интервал времени см. в описаниях соответствующих методов).
// В данной реализации существует две "Головных процедуры":
//    keyScanInput_SystickHandler();   //Ее вызов следует поместить в обработчик прерывания SysTick_Handler()...
//    keyScanInput_EXTIHandler();      //Ее вызов следует поместить в обработчик прерывания EXTI_IRQHandler()...
// Здесь: процедура keyScanInput_SystickHandler обслуживает и Кнопки, и Энкодеры. 
//     Но процедура keyScanInput_EXTIHandler обрабатывает только Энкодеры! И разработана как улучшенная специализированная альтернатива, с более четкой реакцией на изменения состояний Энкодера (не пропускает события). Хотя, keyScanInput_EXTIHandler не использует "интегратор каналов" - поэтому для Энкодеров, обрабатываемых этим методом, настоятельно рекомендуется распаивать аппаратные помехоподавляющие RC-цепочки (как указано в даташите: 10k*10nF).
// Рекомендация: если же вы хотите обрабатывать данной библиотекой ТОЛЬКО ЭНКОДЕРЫ - то целесообразно не использовать keyScanInput_SystickHandler вообще, а использовать только метод keyScanInput_EXTIHandler...
// Легкость конфигурации: 
//     Метод keyScanInput_SystickHandler подключить очень просто - только поместить вызов в обработчик прерывания, который присутствует практически в любом проекте (SysTick-таймер, наверное, самая востребованная периферия).
//     А для подключения метода keyScanInput_EXTIHandler понадобится еще включить и настроить Прерывание EXTI (режим "on Rising/Falling edge") - на двух Портах, через которые подключен Энкодер...



//---------------------------------------------------------------------------


#ifdef STM32F103xE
    // Подключить HAL API
    #include "stm32f1xx_hal.h"
#endif


#ifdef __XC8
    // Подключить определения Микроконтроллера
    #include <xc.h>

    // Подключить стандартные библиотеки
    #include <stdint.h>
    #include <stdbool.h>

    // Костыли для совместимости синтаксиса с примитивным компилятором "Microchip XC8" (деградируем некоторые фичи)
    #define __weak
    #define __inline  inline
    #define assert_param(param)
#endif


// Локальные определения
#include "celeronkeyinputlib.h"



//---------------------------------------------------------------------------
// Forward declarations for private functions:

void keyProcessIntegrator(TInputIntegrator* const Integrator, 
                          uint8_t           const LatchDepth, 
                          uint8_t           const State);

void keyUpdateEncoderStatus(const TInputIntegrator* const Integrator1, 
                            const TInputIntegrator* const Integrator2, 
                                  TEncoderStatus*   const Status, 
                                  TEncoderCounter*  const Counter);

void keyUpdateButtonStatus(const TInputIntegrator* const Integrator, 
                                 TButtonStatus*    const Status);

void keyIncreaseTimeForAllButtons(void);



//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//
// Определение Данных
//
//---------------------------------------------------------------------------

// Примечание: вообще, определение данных может располагаться и в любом другом месте программы (например, в прикладном модуле, использующем библиотеку)... 
// Но тогда не срабатывает макрос NUMBER_OF_ARRAY_ITEMS, для автоматического подсчета размера коллекций, ниже! 
// Поэтому, если инициализируете коллекции keyButtonList/keyEncoderList откуда-то извне, то самостоятельно обновляйте также значения переменных keyButtonListCount/keyEncoderListCount!
// Но я решил разместить инициализацию всех данных прямо здесь, в этом модуле.



// Коллекция всех подключенных Кнопок
//  Внимание: элементы следует перечислять в порядке номеров индексов, заданных соответствующими #define-константами.
TButtonData  keyButtonList[] = {
#ifdef STM32F103xE
    DECLARE_BUTTON(GPIOD, GPIO_PIN_13),   // PD13 - Button: Encoder  (кнопка встроенная в вал энкодера)
    DECLARE_BUTTON(GPIOD, GPIO_PIN_10),   // PD10 - Button: MenuPrev (верхнее меню)
    DECLARE_BUTTON(GPIOD, GPIO_PIN_9),    // PD9  - Button: MenuOk   (верхнее меню)
    DECLARE_BUTTON(GPIOD, GPIO_PIN_8),    // PD8  - Button: MenuNext (верхнее меню)
    DECLARE_BUTTON(GPIOB, GPIO_PIN_15),   // PB15 - Button: Escape   (отменить/СТОП)
    DECLARE_BUTTON(GPIOB, GPIO_PIN_13),   // PB13 - Button: Enter    (сохранить/ПУСК)
#endif
#ifdef __XC8
    DECLARE_BUTTON(&PORTE, 0),    // BUTTON_RIGHT  = RE0
    DECLARE_BUTTON(&PORTE, 1),    // BUTTON_CENTER = RE1
    DECLARE_BUTTON(&PORTE, 2),    // BUTTON_LEFT   = RE2
#endif
};



// Коллекция всех подключенных Энкодеров
//  Внимание: элементы следует перечислять в порядке номеров индексов, заданных соответствующими #define-константами.
#ifndef NO_ENCODERS_AT_ALL
TEncoderData  keyEncoderList[] = {
#ifdef STM32F103xE
    DECLARE_ENCODER(GPIOA, GPIO_PIN_0,  GPIOA, GPIO_PIN_1),  // Внутренний Энкодер: PA0(TIM5_CH1), PA1(TIM5_CH2).
    DECLARE_ENCODER(GPIOC, GPIO_PIN_6,  GPIOC, GPIO_PIN_7),  // Внешний    Энкодер: PC6(TIM8_CH1), PC7(TIM8_CH2).
#endif
#ifdef __XC8
#endif
};
#endif



// Размер коллекций (подсчитывается автоматически)
uint8_t  keyButtonListCount  = NUMBER_OF_ARRAY_ITEMS(keyButtonList);

#ifndef NO_ENCODERS_AT_ALL
uint8_t  keyEncoderListCount = NUMBER_OF_ARRAY_ITEMS(keyEncoderList);
#endif



//---------------------------------------------------------------------------
// Реализация сканирования физических каналов Кнопок и Энкодеров в системе.
// Внимание: данная функция имплементируется прикладным программистом, под свою специфическую аппаратную конфигурацию!
// Хотя, стандартная реализация (предполагающая одиночные кнопки, подключенные к отдельным портам) подходит для большинства случаев.
// Однако, если же потребуется изменить и усложнить реализацию (например, запрограммировать поддержку клавиатуры на резистивных делителях?), то вам придется также изменить базовый тип TInputChannel: для внесения в него уточняющих данных по физической реализации канала, чтобы потом использовать эти данные в коде функции keyScanChannel.
// ПАРАМЕТРЫ:
//    channel - указатель на структуру данных, описывающую "физический канал".
// ВОЗВРАЩАЕТ: 
//    Текущее состояние "физического канала".
// По принятому СТАНДАРТУ, статус "физического канала" возвращается в следующей кодировке: 
//    для Кнопок     "0"=(кнопка отпущена)          или "1"=(кнопка нажата).
//    для Энкодеров  "0"=(канал энкодера разомкнут) или "1"=(канал энкодера замкнут).

//---------------------------------------------------------------------------

__weak __inline uint8_t keyScanChannel(const TInputChannel* const channel)
{
  // Сканировать состояние Канала
#ifdef STM32F103xE
  return ( HAL_GPIO_ReadPin(channel->GPIO, channel->Pin) == GPIO_PIN_RESET );
#endif
#ifdef __XC8
  // Кодировка сигнала в физическом канале кнопки (при простейшей реализации: один порт - одна кнопка; где, Кнопка подключена к Земле "0", или к Питанию "1")
  #define BUTTON_STATE   0
  return ( ((*channel->Port >> channel->Pin)&0x01) == BUTTON_STATE );
  #undef  BUTTON_STATE
#endif
}



//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
// (Головная процедура конвеера обработки кнопок)
//
// KEY_SCAN_INPUT
// Главная процедура, сканирующая кнопки. Должна запускаться часто (каждую 1 мс).
// 	опрашивает состояние физических кнопок,
// 	запускает конвеер математической обработки (помехоподавление и т.п.),
// 	устанавливает значения статусных-регистров для Кнопок и Энкодеров.
//
//---------------------------------------------------------------------------

void keyScanInput_SystickHandler(void) 
{

  //-------------------------------------
  // Обрабатываем Кнопки:
  for(uint8_t i=0; i<keyButtonListCount; i++)
  {
    // Сканируем порты и Интегрируем каналы
    keyProcessIntegrator( &keyButtonList[i].Integrator,
                          CButtonLatchDepth, 
                          keyScanChannel(&keyButtonList[i].Channel) );    //По принятому СТАНДАРТУ, статус входного "физического канала" приходит в следующей кодировке: "0"=(кнопка отпущена) или "1"=(кнопка нажата).

    // Обновляем статусы
    keyUpdateButtonStatus( &keyButtonList[i].Integrator, 
                           &keyButtonList[i].Status );
  }

  // С заданной частотой, наращиваем таймеры удерживаемых кнопок
  // (учитывая, что данная процедура запускается каждую 1 мс)
  
  static volatile uint16_t keySysTickCounter = 0;    //Счетчик отмеряет временные интервалы для периодического запуска метода keyIncreaseTimeForAllButtons...
                                                     //Примечание: так как переменная объявлена как "static внутри функции", то ее инициализация будет произведена только один раз, при старте программы. (c) http://cppstudio.com/post/3298/
                                                     //            И далее, она будет сохранять явно присвоенное ей значение, до конца работы программы.
                                                     //            Причем, данная переменная доступна только из локального контекста данной функции.
  keySysTickCounter++;
  if( keySysTickCounter >= (CButtonSystickFrequency)/(CButtonTimeIncFrequency) )
  {
    keySysTickCounter = 0;
    keyIncreaseTimeForAllButtons();
  }


  //-------------------------------------
  // Обрабатываем Энкодеры (если включено):
#ifndef NO_ENCODERS_AT_ALL
#ifdef CEncoderLatchDepth
  for(uint8_t i=0; i<keyEncoderListCount; i++)
  {
    // Сканируем порты и Интегрируем каналы
    keyProcessIntegrator( &keyEncoderList[i].Integrator1,
                          CEncoderLatchDepth,
                          keyScanChannel(&keyEncoderList[i].Channel1) );    //По принятому СТАНДАРТУ, статус входного "физического канала" приходит в следующей кодировке: "0"=(канал разомкнут) или "1"=(канал замкнут).

    keyProcessIntegrator( &keyEncoderList[i].Integrator2,
                          CEncoderLatchDepth,
                          keyScanChannel(&keyEncoderList[i].Channel2) );    //По принятому СТАНДАРТУ, статус входного "физического канала" приходит в следующей кодировке: "0"=(канал разомкнут) или "1"=(канал замкнут).

    // Обновляем статусы
    keyUpdateEncoderStatus( &keyEncoderList[i].Integrator1, 
                            &keyEncoderList[i].Integrator2, 
                            &keyEncoderList[i].Status, 
                            &keyEncoderList[i].Counter );
  }
#endif
#endif

}


#ifndef NO_ENCODERS_AT_ALL
void keyScanInput_EXTIHandler(void)
{
  //-------------------------------------
  // Обрабатываем Энкодеры (с отключенным Интегратором: LatchDepth=1):
  for(uint8_t i=0; i<keyEncoderListCount; i++)
  {
    // Сканируем порты и Интегрируем каналы
    keyProcessIntegrator( &keyEncoderList[i].Integrator1,
                          1,
                          keyScanChannel(&keyEncoderList[i].Channel1) );    //По принятому СТАНДАРТУ, статус входного "физического канала" приходит в следующей кодировке: "0"=(канал разомкнут) или "1"=(канал замкнут).

    keyProcessIntegrator( &keyEncoderList[i].Integrator2,
                          1,
                          keyScanChannel(&keyEncoderList[i].Channel2) );    //По принятому СТАНДАРТУ, статус входного "физического канала" приходит в следующей кодировке: "0"=(канал разомкнут) или "1"=(канал замкнут).

    // Обновляем статусы
    keyUpdateEncoderStatus( &keyEncoderList[i].Integrator1, 
                            &keyEncoderList[i].Integrator2, 
                            &keyEncoderList[i].Status, 
                            &keyEncoderList[i].Counter );
  }
}
#endif




//---------------------------------------------------------------------------
//
// KEY_PROCESS_INTEGRATOR
// Интеграция "сырого" статуса входного канала (функция математического подавления звона и помех)
// Вызывается после опроса физической кнопки (любой реализации), и получения цифрового кода её текущего статуса: "0" или "1".
//
// ПАРАМЕТРЫ:
// 	Через "State" передаётся "сырой" цифровой код текущего статуса кнопки (в булевском типе: "ложь"="0" или "истина"="не ноль").
//	Указатель "Integrator" передаёт адрес "регистра интегратора" в памяти (ОЗУ).
//	Константа "LatchDepth"=[1..128] специфицирует "глубину защёлки" для текущего канала. (Примечание: наличие данного параметра позволяет задать различную "глубину защёлки" для каждой тактовой кнопоки или энкодера - что позволяет подстраиваться к каждому каналу, ввиду их разной скорости реакции и надёжности...)
//
//---------------------------------------------------------------------------
//
// Кодировка входного сигнала (State):
// 	По принятому СТАНДАРТУ, статус входного "физического канала" приходит в следующей кодировке: "0"=(кнопка отпущена) или "1"=(кнопка нажата).
//  По принятому СТАНДАРТУ, статус входного "физического канала" приходит в следующей кодировке: "0"=(канал разомкнут) или "1"=(канал замкнут).
// 	Примечание: И только так! И не перенастраивается!	Рекомендация: А если ваша реализация схемы кнопок возвращает другой, инверсный код? То просто добавьте в код безусловную логическую инверсию, после чтения статуса из Порта.
//
// 	Вопрос: А зачем так жёстко фиксировать, ведь в процедуре достаточно изменить только одну инструкцию BRTS/BRTC, чтобы кодировка входного сигнала стала инверсной? Можно было бы настраивать, например, директивами условной компиляции...
// 	Ответ:  Для минимизации путаницы - код конвеера обработки кнопок не модифицируется, логика неизменна! 
// 		 Напомню, что кроме Кнопок, через интеграторы обрабатываются также Энкодеры, у которых свои рекомендуемые схемы подключения и кодировки сигналов... 
// 		 Допускается, что разные группы Кнопок/Энкодеров, в системе, могут быть подключены разными схемами, и возвращать свои статусы в разных кодировках, вперемешку...
// 		 Гораздо проще и понятнее, и универсальнее: при написании кода процедуры KEY_SCAN_INPUT, добавить безусловные XOR-инверсии к некоторым определённым "физическим каналам", для приведения кодировки к единому СТАНДАРТУ!
//
//---------------------------------------------------------------------------
//
// ФОРМАТ РЕГИСТРА ИНТЕГРАТОРА (TInputIntegrator):
// 
// 		76543210
// 		Snnnnnnn
// 
// В целом, регистр хранит одно число (signed short int) = [-128,0,+127]
// Результат интеграции - отражается в Sign bit (он же Negative Flag "N"), означает: "0"=(кнопка отпущена) или "1"=(кнопка нажата)...
// Начальное состояние = 0b00000000, что означает: примерно среднее неопределённое положение защёлки, но кнопка всё же на стороне "отпущена" (что соответствует обычной ситуации: кнопки, конструктивно, "нормально разомкнутые").
// 
// Семантически - это инкрементальный двунаправленный счётчик:
// 	Если физический канал (кнопка) возвращает статус "1" ("нажата") - то на этой итерации производится декрементация (-1) регистра счётчика. 
// 	Если физический канал (кнопка) возвращает статус "0" ("отпущена") - то на этой итерации производится инкрементация (+1) регистра счётчика.
// 	Максимальное, по модулю, значение в регистре счётчика определяется константой "глубины защёлки" (LatchDepth) = [-LatchDepth, 0..+(LatchDepth-1)]. Причём, замечу, что здесь значение =0 включается в статус "кнопка отпущена"!
//
//---------------------------------------------------------------------------

void keyProcessIntegrator(TInputIntegrator* const Integrator,   //примечание по синтаксису: это константный указатель на изменяемый объект
                          uint8_t           const LatchDepth, 
                          uint8_t           const State)
{
  assert_param(1<=LatchDepth && LatchDepth<=128);   //проверка: допустимые значения "глубины защелки" = [1..128]

  if(State)
  { // (состояние: кнопка нажата)
    if( *Integrator > -LatchDepth )
      (*Integrator)--;
  }
  else
  { // (состояние: кнопка отпущена)
    if( *Integrator < LatchDepth-1 )
      (*Integrator)++;
  }   
}




#ifndef NO_ENCODERS_AT_ALL
//---------------------------------------------------------------------------
//
// KEY_UPDATE_ENCODER_STATUS
// Фиксация статуса Энкодера (устанавливает значения в "статус-регистре" и "счётчике тиков" Энкодера).
// в зависимости от, динамически изменяющегося, [интегрированного] состояния его двух управляющих каналов: AC и BC.
//
// ПАРАМЕТРЫ:
//	параметры "Integrator1" и "Integrator2" передают текущее "физическое" состояние Энкодера.
//	параметром "Status" передаётся адрес "статусного регистра энкодера" в памяти ОЗУ (который следует обновить).
//  параметром "Counter" передаётся адрес регистра "счётчика тиков" этого Энкодера   (который следует обновить).
//
//---------------------------------------------------------------------------
//
// ФОРМАТ СТАТУСНОГО РЕГИСТРА ЭНКОДЕРА (DEncoderStatus):
// 
// 		 7   6   5   4  |   3   2   1   0
// 		F2  ..  y2  x2  | PreCntr  y1  x1
// 
// 8-битный регистр разделён на две "тетрады": 
// 	В  первой тетраде DEncoderStatus[3:0] = закодировано предыдущее состояние энкодера.
// 	Во второй тетраде DEncoderStatus[7:4] = закодировано последнее  состояние энкодера.
// 	Биты DEncoderStatus[2:3] содержат "предварительный делитель счётчика" = 1..4, через который "по 4 переключения входных сигналов на один тик" преобразуются к фактическому числу тиков, накапливаемому в регистре "счётчика тиков" энкодера.
// 	(бит номер 6 - не используется, и равен 0)
// 
// АЛГОРИТМ:
// 	Программа проверяет текущие состояния входных управляющих каналов энкодера: BC(Y) и AC(X).
//	Если эти значения изменились, относительно текущего "последнего" состояния энкодера (Y2,X2), закодированного в статус-регистре? То происходит фиксация очередного тика:
//	1) "Тетрады" 8-битного статус-регистра меняются местами - таким образом, значения (y2,x2) -> переписываются на место (y1,x1), в часть младших битов... (А что происходит, при этом, с первой тетрадой битов - не важно, они будут переписаны.)
//	2) Новые, актуальные, значения состояний входных управляющих каналов энкодера BC(Y) и AC(X) -> записываются в биты (Y2,X2).
// 	3) Наконец, по формуле, вычисляется булева функция от четырёх переменных F2(x1,x2,y1,y2), которая кодирует направление вращения энкодера.
//	4) Затем, также, наращивается "счётчик тиков", в зависимости от направления вращения...
//
//
// Кодировка:
// 	F = 0	C.W., 	вращение по часовой ("правый винт")	(+1) к счётчику
// 	F = 1	C.C.W.,	вращение против часовой ("левый винт")	(-1) к счётчику
// 	кодировка входных каналов X,Y (=0 или 1), здесь, в принципе, не важна - используется лишь порядок их переключения (функция F симметрична)...
//
// Временные диаграммы:
// 	F = 0	C.W., 	вращение по часовой ("правый винт")	(+1) к счётчику
// 	случай:     1)  2)  3)  4)
// 	AC(X):  1   0   0   1   1
// 	BC(Y):  1   1   0   0   1
// 
// 	F = 1	C.C.W.,	вращение против часовой ("левый винт")	(-1) к счётчику
// 	случай:     5)  6)  7)  8)
// 	AC(X):  1   1   0   0   1
// 	BC(Y):  1   0   0   1   1
// 
// Таблица истинности:
// 		-----------------------------------------------------------------------
// 		|  F2  |  y2  x2  |  y1  x1  |  случай                                |
// 		-----------------------------------------------------------------------
// 		|   -  |   0   0  |   0   0  |  после RESET, запрещена
// 		|   1  |   0   0  |   0   1  |  6) 4/4й такт, перед фиксацией положений
// 		|   0  |   0   0  |   1   0  |  2) 4/4й такт, перед фиксацией положений
// 		|   -  |   0   0  |   1   1  |
// 		|   0  |   0   1  |   0   0  |  3)
// 		|   -  |   0   1  |   0   1  |
// 		|   -  |   0   1  |   1   0  |
// 		|   1  |   0   1  |   1   1  |  5)
// 		-----------------------------------------------------------------------
// 		|   1  |   1   0  |   0   0  |  7)
// 		|   -  |   1   0  |   0   1  |
// 		|   -  |   1   0  |   1   0  |
// 		|   0  |   1   0  |   1   1  |  1)
// 		|   -  |   1   1  |   0   0  |
// 		|   0  |   1   1  |   0   1  |  4)
// 		|   1  |   1   1  |   1   0  |  8)
// 		|   -  |   1   1  |   1   1  |
// 		-----------------------------------------------------------------------
// Примечание: начальное состояние статус-регистра = 0b00000000 - не является "разрешённой комбинацией" входных сигнала, но алгоритм это не сломает. Ну, в худшем случае: сразу после RESET, в "регистр счётчика" энкодера может попасть +1/-1... (не важно!)
//
// Возможные "минимальные нормальные формы" булевой функции:
// МДНФ:	F2(y2,x2,y1,x1) = (НЕ(x2) * НЕ(y1)) + (   x2  *    y1 )
// 	F2(y2,x2,y1,x1) = (НЕ(x1) *    y2 ) + (   x1  * НЕ(y2))	<- мой выбор! (выражение, которое показалось мне удобнее для реализации)
// МКНФ:	F2(y2,x2,y1,x1) = (НЕ(x2) +    y1 ) * (   x2  + НЕ(y1))
// 	F2(y2,x2,y1,x1) = (НЕ(x1) + НЕ(y2)) * (   x1  +    y2 )
//
//
// Примечание: используемый в данном макете Энкодер "RE1203XC1-H01" обладает следующими особенностями:
// 	Оба канала "нормально разомкнутые": в фазе фиксированного положения ручки энкодера (наиболее вероятные положения) - оба канала разомкнуты, ENCODER_STATUS_X2==ENCODER_STATUS_Y2==0;
// 	При повороте ручки на один тик: замыкается сначала один канал, потом другой, потом также размыкается первый, затем второй...	(итого, 4 переключения сигналов на один тик)
// 	Направление вращения ручки (CW/CCW) определяет: который из каналов переключается первым, а второй - следом, за ним...
// 	(Используйте "ПРЕДВАРИТЕЛЬНЫЙ ДЕЛИТЕЛЬ СЧЁТЧИКА", для компенсации лишних переключений.)
//
// Замечу, что если быстро крутануть ручку энкодера так, что не все промежуточные состояния могут быть чётко зафиксированы - то показания глючит и колбасит!
// 	Показания в статус-регистре будут искажаться относительно физического состояния, будут фиксироваться ошибочные комбинации переключений сигналов - появятся ложные срабатывания энкодера: не только пропуски счёта, но показания даже будет колбасить туда-сюда, в обратную сторону...
// 	Поэтому, Пользователь будет вынужден медленнее крутить ручку, чтобы показания фиксировались правильно... Залог правильной работы энкодера в том - чтобы МК работал на порядки быстрее, чем переключаются каналы!
// 	(Выбирайте соответствующий "ВАРИАНТ РЕАЛИЗАЦИИ КОДА", для реализации требуемой помехозащищённости.)
//
// 
// Замечу, однако, что прикладной код никогда не использует "статусный регистр энкодера" напрямую!
// Этот регистр - вспомогательный, и нужен лишь для вычисления направления вращения энкодера, используя булеву функцию: F2(x1,x2,y1,y2) = (НЕ(x1) * y2) + (x1 * НЕ(y2)).
// Вращения энкодера (если таковые были произведены, и их направление) - инкрементируются к регистру "двунаправленного аддитивного счётчика тиков" энкодера.
// (Всё это происходит в служебных функциях "конвеера обработки кнопок".)
//
//---------------------------------------------------------------------------
//
// ФОРМАТ РЕГИСТРА "СЧЁТЧИК ТИКОВ" ЭНКОДЕРА (DEncoderCounter):
//
// Особой специальной структуры не содержит! Это просто знаковое целое число: Signed Int = [-128..127]
//
// Начальное состояние = 0b00000000.
//
// "Счётчик тиков" является конечным в конвеере обработки энкодера, и его использует прикладной код для реакции на жесты с энкодером:
// 	если DEncoderCounter == 0, то вращений [с момента последней обработки] не было, ничего делать не нужно.
// 	если DEncoderCounter > 0,  то зафиксированы вращения, причём в сумме, больше провернули по часовой стрелке: положительное число [1..127] в регистре равно числу тиков [с момента последней обработки].
// 	если DEncoderCounter < 0,  то зафиксированы вращения, причём в сумме, больше провернули против часовой стрелке: отрицательное число [-128..-1] в регистре равно числу тиков [с момента последней обработки].
// 	Причём, между обработками событий энкодера прикладным кодом (которые запускается гораздо реже, чем опрос энкодера) пользователь может колбасить ручку энкодера произвольно в разные стороны, а итоговый результат будет правильно отражён в "Счётчике тиков"!
// В обработчике событий - просто приплюсуйте результат из "Счётчика тиков" к вашей управляемой переменной величине...
// 	А затем, после обработки энкодера прикладным кодом и произведения ответной реакции, "СБРОСьте" регистр "Счётчик тиков" в ноль (но "статусный регистр" энкодера не трогайте!) -> так снова устанавливается статус-кво: энкодер = "не вращался".
// 	Это простой способ сообщить остальному прикладному коду, что данное событие уже обработано и не требует дальнейшего участия!
//
//---------------------------------------------------------------------------


// Выберите, один из трёх, вариантов реализации кода (раскомментируйте соответствующий символ):
//#define ENCODER_USE_SIMPLIFIED_CODE  1    // "Упрощённый код"     (простой алгоритм, маленький и быстрый код! не защищён от ошибочных входных сигналов; предделитель фиксирован = 4 раза) 	- рекомендуется использовать на стабильном железе: быстром Микроконтроллере и при низком уровне помех по входным каналам.	Примечание: в этом варианте, код "предварительного делителя счётчика" не используется - но делитель есть и фиксирован: показания "счётчика тиков" делятся в 4 раза.
//#define ENCODER_USE_ACADEMIC_CODE    2    // "Академический код"  (самый компактный код и поражает воображение своим изяществом! но не защищён от ошибочных входных сигналов) 			- преимущества: он проще/меньше/быстрее параноидального кода, и с ним работает полноценный "предварительный делитель счётчика"!	Обычно, не рекомендуется его использовать: т.к. он является "серединкой на половинку" среди других вариантов, и особых преимуществ не даёт... (На плохом железе: "Академический код" глючит столь же интенсивно, как и "Упрощённый код", но они по разному ощущаются - выбери себе глюки по вкусу!)
  #define ENCODER_USE_PARANOID_CODE    3    // "Параноидальный код" (тупой алгоритм и избыточный код, перебирающий все комбинации входных сигналов; защищён от "ОДНОКРАТНЫХ ошибок" по входу!)	- предполагается, будет математически сглаживать и преодолевать последствия некоторых ошибок опроса физических каналов энкодера (при пропуске одного такта - запрещённая комбинация по входу, будет проигнорирована).	Используйте этот вариант на плохом железе: при медленном микроконтроллере, или когда опрос энкодера происходит с ошибками.

// Выберите коэффициент "предварительного делителя счётчика тиков" энкодера:
// 	Если символ закомментирован - то предделитель отключён!
// 	Примечание: Также, предделитель не используется в режиме ENCODER_USE_SIMPLIFIED_CODE! (Там коэффициент деления фиксирован, вследствие особенностей алгоритма: устанавливается = 4 раза.)
#define ENCODER_USE_PRECOUNTER  4    // (Здесь, допустимые значения предделителя = 2,3,4 переключения / на один тик счётчика. Рекомендуется = 4.)



void keyUpdateEncoderStatus(const TInputIntegrator* const Integrator1, 
                            const TInputIntegrator* const Integrator2, 
                                  TEncoderStatus*   const Status, 
                                  TEncoderCounter*  const Counter)
{
  
  //--- Этап1: ПРОВЕРКА ВХОДНЫХ КАНАЛОВ
  
  // Извлечь старые/прежние состояния каналов энкодера во временную переменную:
  uint8_t oldstat = ((*Status) & ((1<<ENCODER_STATUS_Y2)|(1<<ENCODER_STATUS_X2)));   //Примечание: поскольку тип TEncoderStatus имеет модификатор volatile, что препятствует оптимизатору - введем локальную временную переменную базового типа, для разрешения некоторых оптимизаций...
  
  // Записать новые/актуальные состояния каналов энкодера во временную переменную:
  uint8_t tempstat = ( ((*Integrator1) & (1<<INTEGRATOR_IS_PRESSED)) >> (INTEGRATOR_IS_PRESSED - ENCODER_STATUS_X2) )|  // Загружаем текущее состояние ПЕРВОГО КАНАЛА (замкнут или разомкнут) во временную переменную, в битовую позицию X2 статус-регистра Энкодера.
                     ( ((*Integrator2) & (1<<INTEGRATOR_IS_PRESSED)) >> (INTEGRATOR_IS_PRESSED - ENCODER_STATUS_Y2) );  // Загружаем текущее состояние ВТОРОГО КАНАЛА (замкнут или разомкнут) во временную переменную, в битовую позицию Y2 статус-регистра Энкодера.

  // Сравнить текущее состояние энкодера и зафиксированое в его статусном регистре:
  // если они одинаковые, то обновлять регистры состояния энкодера не нужно - выходим...
  if( tempstat == oldstat ) return;


  // Итак, состояние энкодера изменилось - нужно обновить его регистры!
  // Подготовка: 
  //    Сформировать значения "состояний входных каналов" в формате статус-регистра...
  //    "Тетрады" 8-битного статус-регистра меняются местами - таким образом, значения (y2,x2) -> переписываются на место (y1,x1), в часть младших битов...
  //    Новые, актуальные, значения состояний входных управляющих каналов энкодера BC(Y) и AC(X) -> записываются в биты (Y2,X2).
  tempstat |= oldstat>>4;  
  //    Сохранить значение Предделителя во временную переменную...
  oldstat = ((*Status) & (3<<ENCODER_STATUS_PRECOUNTER));
  
  

  //--- Этап2: РАСЧЕТ НАПРАВЛЕНИЯ ВРАЩЕНИЯ

  // Требуется сформировать значение функции "направление вращения" (F2)...
  // Вход в блок:
  //    oldstat  = |    0    0    0    0  |  PreCntr    0    0   |
  //    tempstat = |    0    0   y2   x2  |   0    0   y1   x1   |
	// Выход из блока:
  //    tempstat = |   F2    0   y2   x2  |   0    0   y1   x1   |
#if defined( ENCODER_USE_SIMPLIFIED_CODE )

  // Упрощенная реализация: изменяющая значение функции только на 4/4й такт переключения входных сигналов - только в фазе фиксированного положения, когда ENCODER_STATUS_X2==ENCODER_STATUS_Y2==0.
  // Из восьми "разрешённых входных комбинаций" для булевой функции F2(x1,x2,y1,y2) - рассматриваются только две "характерные комбинации"...


  // Если pattern=|    0    0    0    0  |   0    0    1    0   | случай 2) 4/4й такт, перед фиксацией положений:	когда переключается канал Y==1..0, то фиксируем новое значение функции F2=0
	if(      tempstat == ((0<<ENCODER_STATUS_Y2)|(0<<ENCODER_STATUS_X2)|(1<<ENCODER_STATUS_Y1)|(0<<ENCODER_STATUS_X1)) )
  {
    //tempstat |= (0<<ENCODER_STATUS_F2);   //оптимизация: нулевое значение можно не прибавлять
  }
	// Если pattern=|    0    0    0    0  |   0    0    0    1   | случай 6) 4/4й такт, перед фиксацией положений:	когда переключается канал X==1..0, то фиксируем новое значение функции F2=1
	else if( tempstat == ((0<<ENCODER_STATUS_Y2)|(0<<ENCODER_STATUS_X2)|(0<<ENCODER_STATUS_Y1)|(1<<ENCODER_STATUS_X1)) )
  {
    tempstat |= (1<<ENCODER_STATUS_F2);
  }
  // Иначе, сохраняем прежнее значение функции F2, но обновляем состояния каналов!
  else  
  {
    *Status = ((*Status) & (1<<ENCODER_STATUS_F2)) | tempstat;
    return;   // В этом случае, дальнейшая обработка прерывается (т.е. счетчик тиков наращивать не следует)
  }
  // Примечание: если было "обновлено значение функции" (хотя само значение может остаться прежним) - то исполняем код далее, и попадём на модификацию "счётчика тиков"...
  // Причем, в этом варианте, Предделитель вообще не используется (нулевые биты)!

  
  
#elif defined( ENCODER_USE_ACADEMIC_CODE )

  // (академическая реализация: реагирующая на любое изменение входных сигналов)	
  // Вычислить значение булевой функции: F2(x1,x2,y1,y2) = (НЕ(x1) * y2) + (x1 * НЕ(y2))

  tempstat |= (
               ((                                          //вычисляем значение функции F2
                 !(tempstat&(1<<ENCODER_STATUS_X1))  &&    // НЕ(x1)
                  (tempstat&(1<<ENCODER_STATUS_Y2)) )||(   // y2
                  (tempstat&(1<<ENCODER_STATUS_X1))  &&    // x1
                 !(tempstat&(1<<ENCODER_STATUS_Y2))        // НЕ(y2)
               )) ? 1 : 0                                  //преобразуем тип результата: из логического в число ("ложь"=0 или "истина"=1)
              )<<ENCODER_STATUS_F2;                        //значение функции F2 выдвигаем на нужную позицию в регистре


#else  // ENCODER_USE_PARANOID_CODE

  // (параноидальная реализация: тупой алгоритм, явно перебирающий все 8шт. "разрешённых комбинаций" входных сигналов. 
  // "Запрещённые комбинации" 8шт. - игнорируются, что обеспечивает защиту от "однократных ошибок" по входу.)


  // Если pattern=|    0    0    1    0  |   0    0    1    1   | случай 1), то присвоить новое значение функции F2=0
  if( tempstat == ((1<<ENCODER_STATUS_Y2)|(0<<ENCODER_STATUS_X2)|(1<<ENCODER_STATUS_Y1)|(1<<ENCODER_STATUS_X1)) 
  // Если pattern=|    0    0    0    0  |   0    0    1    0   | случай 2), то присвоить новое значение функции F2=0
  ||  tempstat == ((0<<ENCODER_STATUS_Y2)|(0<<ENCODER_STATUS_X2)|(1<<ENCODER_STATUS_Y1)|(0<<ENCODER_STATUS_X1)) 
  // Если pattern=|    0    0    0    1  |   0    0    0    0   | случай 3), то присвоить новое значение функции F2=0
  ||  tempstat == ((0<<ENCODER_STATUS_Y2)|(1<<ENCODER_STATUS_X2)|(0<<ENCODER_STATUS_Y1)|(0<<ENCODER_STATUS_X1)) 
  // Если pattern=|    0    0    1    1  |   0    0    0    1   | случай 4), то присвоить новое значение функции F2=0
  ||  tempstat == ((1<<ENCODER_STATUS_Y2)|(1<<ENCODER_STATUS_X2)|(0<<ENCODER_STATUS_Y1)|(1<<ENCODER_STATUS_X1)) )
  {
    //tempstat |= (0<<ENCODER_STATUS_F2);   //оптимизация: нулевое значение можно не прибавлять
  }
  
  // Если pattern=|    0    0    0    1  |   0    0    1    1   | случай 5), то присвоить новое значение функции F2=1
  else if( tempstat == ((0<<ENCODER_STATUS_Y2)|(1<<ENCODER_STATUS_X2)|(1<<ENCODER_STATUS_Y1)|(1<<ENCODER_STATUS_X1))
  // Если pattern=|    0    0    0    0  |   0    0    0    1   | случай 6), то присвоить новое значение функции F2=1
  ||       tempstat == ((0<<ENCODER_STATUS_Y2)|(0<<ENCODER_STATUS_X2)|(0<<ENCODER_STATUS_Y1)|(1<<ENCODER_STATUS_X1))
  // Если pattern=|    0    0    1    0  |   0    0    0    0   | случай 7), то присвоить новое значение функции F2=1
  ||       tempstat == ((1<<ENCODER_STATUS_Y2)|(0<<ENCODER_STATUS_X2)|(0<<ENCODER_STATUS_Y1)|(0<<ENCODER_STATUS_X1))
  // Если pattern=|    0    0    1    1  |   0    0    1    0   | случай 8), то присвоить новое значение функции F2=1
  ||       tempstat == ((1<<ENCODER_STATUS_Y2)|(1<<ENCODER_STATUS_X2)|(1<<ENCODER_STATUS_Y1)|(0<<ENCODER_STATUS_X1)) )
  {
    tempstat |= (1<<ENCODER_STATUS_F2);
  }
  
  // Иначе, сохраняем прежнее значение функции F2, но обновляем состояния каналов!
  else  
  {
    *Status = ((*Status) & (1<<ENCODER_STATUS_F2)) | oldstat | tempstat;
    return;   // В этом случае, дальнейшая обработка прерывается (т.е. счетчик тиков наращивать не следует)
  }
  // Примечание: если было "обновлено значение функции" (хотя само значение может остаться прежним) - то исполняем код далее, и попадём на модификацию "счётчика тиков"...
  
#endif



  //--- Этап3: РАСЧЕТ ПРЕДДЕЛИТЕЛЯ
  
  oldstat >>= ENCODER_STATUS_PRECOUNTER;    //Выдвигаем значащие разряды в нулевую позицию, чтобы использовать обычную арифметику (удобнее)

  // Требуется нарастить счетчик Предделителя, причем "по модулю", заданному значением константы...
  // Вход в блок:
  //    oldstat  = |    0    0    0    0  |   0    0   PreCntr   |
  //    tempstat = |   F2    0   y2   x2  |   0    0   y1   x1   |
	// Выход из блока:
  //    oldstat  = |    0    0    0    0  |   0    0  PreCntr++  |  (итоговое значение счетчика предделителя)
  //    tempstat = |   F2    0   y2   x2  | PreCntr++  y1   x1   |  (итоговое содержимое статус-регистра)
#if defined(ENCODER_USE_PRECOUNTER) && !defined(ENCODER_USE_SIMPLIFIED_CODE)

  // Нарастить счётчик "предварительного делителя":
  //    Имейте в виду, что большинство (если не все?) "инкрементальных энкодеров" осуществляют по 4 переключения сигналов на один тик (поворот ручки между "положениями с фиксацией")!
  //    Поэтому, чувствительнось энкодера, конечно, повышается... но число регистрируемое в "Счётчике тиков" (используемое в прикладном коде) - потребуется делить на 4 раза, чтобы получить фактическое число переключений!
  //    Здесь используется специальный "предварительный счётчик" (=1..4), через который "по 4 переключения входных сигналов на один тик" преобразуются к фактическому числу тиков, в регистре "счётчика тиков" энкодера...
  
  // Если F2 = 1,	то вращение против часовой C.C.W. ("левый винт"), требуется (-1) к счётчику
  if(tempstat & (1<<ENCODER_STATUS_F2))
  {
    oldstat--;
    
    // И для обеспечения правильного счета "по модулю", требуется внести коррекцию:
    if(oldstat >= ENCODER_USE_PRECOUNTER) 
      oldstat = (ENCODER_USE_PRECOUNTER-1);
  }
  // Если F2 = 0, то вращение по часовой C.W. ("правый винт"), треуется (+1) к счётчику
  else
  {
    oldstat++;

    // И для обеспечения правильного счета "по модулю", требуется внести коррекцию:
    if(oldstat >= ENCODER_USE_PRECOUNTER) 
      oldstat = 0;    //Замечу: при сбросе Предделителя в ноль - как раз и будет посчитан тик!
  }
  
  tempstat |= (oldstat<<ENCODER_STATUS_PRECOUNTER);
  
#endif
  // Подсчитанное значение сохраняется в статус-регистр энкодера:
  *Status = tempstat;



  //--- Этап4: ПОДСЧЕТ ТИКОВ ЭНКОДЕРА

  // Требуется нарастить "счётчик тиков", в зависимости от направления вращения...
  // Вход в блок:
  //    oldstat  = |    0    0    0    0  |   0    0  PreCntr++  |  (итоговое значение счетчика предделителя)
  //    tempstat = |   F2    0   y2   x2  | PreCntr++  y1   x1   |  (итоговое содержимое статус-регистра)
  
  //Примечание: тик будет посчитан, всякий раз, при обнулении значении Предделителя...
  if(oldstat == 0)
  {
    // Если F2 = 1,	то вращение против часовой C.C.W. ("левый винт"), требуется (-1) к счётчику
    if(tempstat & (1<<ENCODER_STATUS_F2))
    {
      // пока НЕ достигли НИЖНЕГО хранимого предела...
      if(*Counter > INT8_MIN)
        (*Counter)--;
    }
    // Если F2 = 0, то вращение по часовой C.W. ("правый винт"), треуется (+1) к счётчику
    else
    {
      // пока НЕ достигли ВЕРХНЕГО хранимого предела...
      if(*Counter < INT8_MAX)
        (*Counter)++;
    }
  }

}
#endif




//---------------------------------------------------------------------------
//
// KEY_UPDATE_BUTTON_STATUS
// Фиксация статуса Кнопки (устанавливает значения в статус-регистре Кнопки),
// в зависимости от, динамически изменяющегося, [интегрированного] состояния её канала.
//
// ПАРАМЕТРЫ:
//	параметром "Integrator" передаётся адрес "регистра интегратора" (в памяти ОЗУ), который кодирует текущее "физическое" состояние кнопки.
//	параметром "Status" передаётся адрес "статусного регистра кнопки" (в памяти ОЗУ), который следует обновить.
//
//---------------------------------------------------------------------------
//
// ФОРМАТ СТАТУСНОГО РЕГИСТРА КНОПКИ (DButtonStatus):
// 
// 		76543210
// 		HPTnnnnn
// 
// nnnnn = Пять битов   DButtonStatus[4:0] = счётчик количества дискретных единиц времени (по 1/CButtonTimeIncFrequency сек), в течение которых Кнопка удержива(лась/ется) "нажатой".
// HPT   = В трёх битах DButtonStatus[7:5] = кодируется итоговый "статус-код кнопки" (см. макроопределения констант).
// T     = Флаг "времени удержания" кнопки: 0-короткое или 1-длинное.
// P     = Флаг "зафиксировано полноценное нажатие кнопки": "0" - кнопка не нажималась, "1" - было нажатие.
// H     = Флаг "кнопка удерживается в нажатом состоянии": "0" - сейчас кнопка "отпущена", "1" - сейчас кнопка "нажата и удерживается".
// 
// Начальное состояние = 0b00000000 означает: кнопка "не нажата и не нажималась", исходное положение для всех кнопок - бывает только после "сброса"...	(статус-код кнопки = "не нажата"; счётчик времени предыдущего нажатия = обнулён)
// Начальное состояние = 0b11111111 означает: кнопка "удерживается и отпущена одновременно" - это служебное, исключительное состояние: "фиксация, до ожидания следующего отпускания" кнопки - ОТЛОЖЕННЫЙ СБРОС...	(запрещённый статус-код кнопки = запрещает прикладному коду реакцию на эту кнопку)	(примечание: а при следующем отпускании физической кнопки, статус-регистр будет АВТОМАТИЧЕСКИ "сброшен в ноль", в исходное положение!)
// (Примечание: также, после обработки статуса кнопки прикладным кодом, статусный регистр РЕКОМЕНДУЕТСЯ просто сбрасываеть "в ноль" или "в единицы" - это простой способ сообщить остальному прикладному коду, что данное событие уже обработано и не требует дальнейшего участия...)
//
//---------------------------------------------------------------------------

void keyUpdateButtonStatus(const TInputIntegrator* const Integrator, 
                                 TButtonStatus*    const Status)
{
  uint8_t tempstat = (*Status);   //Примечание: поскольку тип TButtonStatus имеет модификатор volatile, что препятствует оптимизатору - введем локальную временную переменную базового типа, для разрешения некоторых оптимизаций...
  
  // Проверяем текущее (актуальное) состояние канала кнопки: "удерживается" или "отпущена"?
  if((*Integrator) & (1<<INTEGRATOR_IS_PRESSED))
  { 
    // (состояние: физическая кнопка сейчас "удерживается")    
    
    // Однако, Если в статус-регистре Кнопки ПОКА НЕ установлен Флаг "кнопка удерживается в нажатом состоянии" ?
    if( !(tempstat & (1<<BUTTON_IS_HOLDDOWN)) )
    { 
      // (состояние: но в статус-регистре ещё хранится старый статус "отпущена")
      
      // Тогда, следует установить статус = "кнопка удерживается в нажатом состоянии"; 
      // При этом, счётчик "времени предыдущего удержания" принудительно обнуляется; 
      // И т.к. кнопку только-только нажали, то также сбрасывается её "статус-код" (до прояснения ситуации)...
      (*Status) = (1<<BUTTON_IS_HOLDDOWN);
    }
  }
  else
  { 
    // (состояние: физическая кнопка сейчас "отпущена")
   
    // Однако, Если в статус-регистре Кнопки ВОПРЕКИ установлен Флаг "кнопка удерживается в нажатом состоянии" ?
    if(tempstat & (1<<BUTTON_IS_HOLDDOWN))
    { 
      // (состояние: но в статус-регистре ещё хранится старый статус "удерживается")

      if(tempstat & (1<<BUTTON_IS_PRESSED))
      { 
        // Если в статус-регистре обнаружена запрещенная логикой комбинация: одновременно установлены флаги "кнопка удерживается в нажатом состоянии" (BUTTON_IS_HOLDDOWN) и "зафиксировано полноценное нажатие кнопки" (BUTTON_IS_PRESSED)?
        // Это означает: установленное вручную, служебное исключительное состояние "ОТЛОЖЕННЫЙ СБРОС" - блокировка статус-регистра до следующего отпускания физической кнопки.
        // Такой статус обычно кнопка получает, если прикладной код обрабатывает событие "удержание" (неполное нажатие), ПОСЛЕ исполнения соответствующего обработчика...
  
        // Но так как физическую кнопку только что отпустили - то статус-регистр следует реально "сбросить в ноль", в исходное положение.
        (*Status) = 0;
      }
      else
      { 
        // Иначе, похоже, прикладной код не обрабатывал событие "удержания"...
        
        // Возвращаем кнопке статус "отпущена" (~BUTTON_IS_HOLDDOWN). 
        // Но, при этом, фиксируем, что "было нажатие" (BUTTON_IS_PRESSED).
        // Замечу, что при этом, другие биты статус-регистра мы не трогаем! Таким образом, там сохраняются значения Флага и Счетчика "времени удержания"...
        (*Status) = (tempstat & ~(1<<BUTTON_IS_HOLDDOWN)) | (1<<BUTTON_IS_PRESSED);
      }
    }
  }

}




//---------------------------------------------------------------------------
// (Головная процедура конвеера обработки кнопок)
//
// KEY_ENHANCE_TIME_FOR_ALL_BUTTONS
// Наращивает таймеры для удерживаемых кнопок (должна запускаться по событию таймера, точно раз в 0.5 сек)
// 	Для Энкодеров не используется - предназначена только для обработки Кнопок!
// 	С физическими кнопками также не работает, а только перебирает/обрабатывает их Статусные регистры!
//
// АЛГОРИТМ:
// 	для кнопок удерживаемых в нажатом состоянии, 
//	наращивает "счётчик времени удержания" (если он ещё меньше своего максимума < 0b11111),
// 	и также, обновляет значение Флага "времени удержания" кнопки = 0-короткое или 1-длинное.
//
//---------------------------------------------------------------------------

void keyIncreaseTimeForAllButtons(void) 
{
  // Перебираем все Кнопки
  for(uint8_t i=0; i<keyButtonListCount; i++)
  {
    uint8_t tempstat = keyButtonList[i].Status;   //Примечание: поскольку тип TButtonStatus имеет модификатор volatile, что препятствует компилятору Си оптимизировать быстродействие - введем локальную временную переменную базового типа, для разрешения некоторых оптимизаций...

    // Наращивание "счетчика времени удержания" производится только для кнопок, находящихся в режиме: "удерживается", но "не отпущена", т.е. не обработана... (а Кнопки во всех других режимах, в т.ч. в "отложенном сбросе" - игнорируем!)
    if(  (tempstat & (1<<BUTTON_IS_HOLDDOWN)) &&    //если установлен Флаг "кнопка удерживается в нажатом состоянии"
        !(tempstat & (1<<BUTTON_IS_PRESSED))  )     //но сброшен Флаг "зафиксировано полноценное нажатие кнопки"?
    {
      // (состояние: текущая кнопка нажата и удерживается)
      
      uint8_t counter = (tempstat & (0x1F<<BUTTON_HOLDING_TIME));  //извлечь биты "счётчика времени удержания" во временную переменную

      // Увеличить значение "счётчика времени удержания", если он еще не заполнен до предела ( 0x1F = 0b11111 )
      if(counter < (0x1F<<BUTTON_HOLDING_TIME))
      {
        counter += (1<<BUTTON_HOLDING_TIME);    //инкрементировать значение счетчика
        
        // Результат записать в статус-регистр
        keyButtonList[i].Status = (1<<BUTTON_IS_HOLDDOWN)   |
                                  (0<<BUTTON_IS_PRESSED)    |
                                  counter                   |
                                  (((counter < CButtonLongHoldDuration<<BUTTON_HOLDING_TIME) ? 0 : 1)<<BUTTON_HOLDEN_LONG);   // Обновить значение Флага "длительность удержания"...
        
        // Пояснение: Обновить значение Флага "длительность удержания"...
        //    если counter <  CButtonLongHoldDuration ("Short" time), то Флаг "длительность удержания" = 0-короткое
        //    если counter >= CButtonLongHoldDuration ("Long" time),  то Флаг "длительность удержания" = 1-длинное
      }
      
      
      #ifdef SMART_BUTTON_ENABLE
      // Также, увеличить счетчик времени, прошедшего с момента последнего сканирования "умного статуса"
      if(keyButtonList[i].SmartTimer < UINT8_MAX)
         keyButtonList[i].SmartTimer++;
      #endif
      
    }
  }

}




//---------------------------------------------------------------------------
// (Головная процедура конвеера обработки кнопок)
//
// KEY_RESET_STATUS_FOR_ALL_BUTTONS
// Обнулить все зарегистрированные события от Кнопок и Энкодеров (вызывается при переходе интерфейса в другую Подсистему, в которой задействованы другие группы кнопок).
// Использование данной процедуры подавляет "эффекты" от лишних нажатий кнопок, зарегистрированных но не обработанных, в предыдущем режиме интерфейса - чтобы они, внезапно, не были обнаружены и обработаны в новом режиме интерфейса (когда уже не актуальны).
//
//
// Инструкция к применению: 
// 	Обычно, при обработке кнопочных событий, если распознаётся нажатие управляющей кнопки (одной или группы) - то реализуется соответствующая прикладная реакция, и статус обработанных кнопок сбрасывается (но только статус для обработанных кнопок!).
// 	Если, в некотором режиме интерфейса, часть кнопок не задействована - то они не опрашиваются, не срабатывают, их статус не обнуляется, а запоминается и хранится (такая кнопка становится "миной отложенного действия").
// 	Следует также учитывать "защиту от дурака": пользователь будет нажимать на всё подряд!
// 	При реализации прикладной логики вашего Устройства: Вызывайте данную процедуру единожды, всякий раз, когда переключаете интерфейс в другую Подсистему - это "разминирует все заложенные ловушки".
//
// Принцип действия:
// 	Статус-регистры всех Кнопок "СБРАСЫВАЮТСЯ В ЕДИНИЦЫ (SER)" - так установится статус "ОТЛОЖЕННЫЙ СБРОС".	(Напомню: Далее, для тех кнопок которые отпущены, или как только они будут отпущены, статус-регистры автоматически установятся в исходное, нулевое состояние.)
// 	Счётные-регистры всех Энкодеров обнуляются ("счётчик тиков"=0).
//
//---------------------------------------------------------------------------

void keyResetStatusForAllButtons(void) 
{
  uint8_t i;
  
  // Статус-регистры всех Кнопок СБРАСЫВАЮТСЯ В "ОТЛОЖЕННЫЙ СБРОС":
  for(i=0; i<keyButtonListCount; i++)
    keyButtonList[i].Status = RESET_BUTTON_STATUS;    // Примечание: эквивалентно действию макроса  BUTTON_RESET(i)

#ifndef NO_ENCODERS_AT_ALL
  // Счётные-регистры всех Энкодеров обнуляются:
  // (примечание: статусные регистры энкодеров игнорируются)
  for(i=0; i<keyEncoderListCount; i++)
    keyEncoderList[i].Counter = 0;                    // Примечание: эквивалентно действию макроса  ENCODER_RESET(i)
#endif
}




//---------------------------------------------------------------------------
// Вспомогательная функция: 
//
//  возвращает TRUE - если есть кнопки с необработанными статусами...
//      Т.е. если хоть какая-то Кнопка нажималась РАНЕЕ или удерживается прямо СЕЙЧАС, 
//      но она ещё не обработана и не сброшена через BUTTON_RESET.
//
// Назначение: данный метод полезен для выявления "нажатия на любую клавишу", 
//      если обработчик событий запускается периодически но очень редко, 
//      и сам момент оперативного нажатия мог бы пропустить (если кнопку быстро отпустили), 
//      но отреагировать на событие требуется, даже и постфактум.
//      Метод используется в циклах ожидания типа "Press any key to continue..."
//
// Примечание: при сканировании статусов, Кнопки в состоянии "отложенный сброс" игнорируются.
// Таким образом, если событие уже отработано в прикладном коде, то такие кнопки 
// решено считать "не нажатыми" (даже если физическая кнопка всё ещё удерживается).
//---------------------------------------------------------------------------

uint8_t keyIfAnyButtonUnhandled(void)
{
  for(uint8_t i=0; i<keyButtonListCount; i++)
  {
    TButtonStatus status = keyButtonList[i].Status;
    if( (status                              != RESET_BUTTON_STATUS)                 &&    // Исключение: при сканировании статусов, игнорируем Кнопки в состояниии "отложенный сброс"...
        ((status&(0x07<<BUTTON_STATUS_CODE)) != (BSC_NotPressed<<BUTTON_STATUS_CODE)) )    // Примечание: выражение эквивалентно макросу  !BUTTON_REGISTER_HAVE_STATUS(status, BSC_NotPressed)
    {
      return 1;                                                                            // Нашли нажатую Кнопку - возвращаем TRUE...
    }
  } 
  return 0;                                                                                // Ничего не нажато - возвращаем FALSE...
}


//---------------------------------------------------------------------------
// Вспомогательная функция: 
//
//  возвращает TRUE - если ПРЯМО СЕЙЧАС НАЖАТА и удерживается хоть какая-то Кнопка,
//      но она ещё не обработана и не сброшена через BUTTON_RESET.
//
// Примечание: при сканировании статусов, Кнопки в состоянии "отложенный сброс" игнорируются.
// Таким образом, если событие уже отработано в прикладном коде, то такие кнопки 
// решено считать "не нажатыми" (даже если физическая кнопка всё ещё удерживается).
//---------------------------------------------------------------------------

uint8_t keyIfAnyButtonHolddown(void)
{
  for(uint8_t i=0; i<keyButtonListCount; i++)
  {
    TButtonStatus status = keyButtonList[i].Status;
    if( (status != RESET_BUTTON_STATUS)    &&   // Исключение: при сканировании статусов, игнорируем Кнопки в состояниии "отложенный сброс"...
        (status & (1<<BUTTON_IS_HOLDDOWN)) )    // Примечание: выражение эквивалентно макросу  BUTTON_HAVE_FLAG(status, BUTTON_IS_HOLDDOWN)
    {
      return 1;                                 // Нашли нажатую Кнопку - возвращаем TRUE...
    }
  } 
  return 0;                                     // Ничего не нажато - возвращаем FALSE...
}




#ifdef SMART_BUTTON_ENABLE
//---------------------------------------------------------------------------
// Сканировать "Smart Button" и вернуть код:
//  0 = кнопка не нажата                (ничего не прибавлять)
//  1 = кнопка в ShortHold, однократно  (+1 к настраиваемой величине) 
//  1 = кнопка в LongHold, многократно  (+1 к настраиваемой величине, с периодичностью настраиваемой WaitingScheme) 
//---------------------------------------------------------------------------

uint8_t keyIfSmartButtonPressed(uint8_t ID, uint8_t WaitingScheme)
{
  TButtonStatus   status = keyButtonList[ID].Status;
  TButtonSmartTimer time = keyButtonList[ID].SmartTimer;
  
  
  // Состояние: кнопка не нажата или в состояниии "отложенный сброс".
  if(!(status & (1<<BUTTON_IS_HOLDDOWN))                                      // Пояснение: поскольку для "умных кнопок", обычно, не используется метод BUTTON_RESET(), то контролировать приходится только состояние мгновенного флага.
     || (status == RESET_BUTTON_STATUS))                                      // Тем не менее, для "умной кнопки" также может быть применен "отложенный сброс" - для досрочного прерывания реакции на нажатую кнопку (до ее фактического отпускания) - например, если подстраиваемая величина достигла своего максимума...
  {
    keyButtonList[ID].SmartTimer = 0;                                         // Замечу: ненажатые Кнопки - также, обязательно надо сканировать, чтобы сбросить их "умный таймер".
                                                                              // Т.е. если Кнопка - "умная", то ее просто нужно ВСЕГДА сканировать в общем цикле.
    return 0;
  }
  
  
  // Состояние: кнопка в ShortHold, срабатывает однократно.
  if(BUTTON_REGISTER_HAVE_STATUS( status, BSC_ShortHold )  &&
     time < CButtonLongHoldDuration)
  {
    keyButtonList[ID].SmartTimer = CButtonLongHoldDuration;                   // Приемчик, для однократного срабатывания данного события (задвигаем "умный таймер" за пределы "ShortHold").
    return 1;
  }
  
  
  // Состояние: кнопка в LongHold, срабатывает многократно.
  if(BUTTON_REGISTER_HAVE_STATUS( status, BSC_LongHold ))
  {
    status = (status>>BUTTON_HOLDING_TIME & 0x1F);                            // Выделяем значение таймера удержания кнопки.
    if( 
        (WaitingScheme == 0)  ||                                              //Схема: опрос "умной кнопки" должен быть реализован в прикладном коде с требуемой частотой (задержка отключена)...
      
        (WaitingScheme == 1   &&                                              //Схема: срабатываем с периодичностью CButtonTimeIncFrequency...
          (time)
        )                     ||
    
        (WaitingScheme == 2   &&                                              //Схема: компромиссная...
          ( 
            ((status-CButtonLongHoldDuration) > CButtonTimeIncFrequency*4)    //когда "длинное удержание" длится уже свыше 4 секунд, то ожидание отключается (приращение величины станет происходить с частотой опроса, которая должна регулироваться в прикладном коде)
            || (time)                                                         //иначе, первые 4 секунд, срабатываем с периодичностью CButtonTimeIncFrequency (небольшая задержка)...
          )
        )                     ||

        (WaitingScheme == 3   &&                                              //Схема: чем дольше кнопка удерживается, тем чаще срабатывает данное событие...
          ( 
            (
              ((status-CButtonLongHoldDuration) > CButtonTimeIncFrequency*4)  //когда "длинное удержание" длится уже свыше 4 секунд,
              && (time >= CButtonTimeIncFrequency/4)                          //то срабатываем каждые четверть секунды
            ) || (time >= CButtonTimeIncFrequency/2)                          //иначе срабатываем каждые пол секунды
          )
        )                     ||

        (WaitingScheme == 4   &&                                              //Схема: чем дольше кнопка удерживается, тем чаще срабатывает данное событие...  (Примечание: использовалась в проекте "Dimmer".)
          ( 
            (
              ((status-CButtonLongHoldDuration) > CButtonTimeIncFrequency*1.5)  //когда "длинное удержание" длится уже свыше 1.5 секунд,
#if (CButtonTimeIncFrequency >= 10)
              && (time >= CButtonTimeIncFrequency/10)                         //то срабатываем десять раз в секунду
#endif                 
            ) || (time >= CButtonTimeIncFrequency/4)                          //иначе срабатываем каждые четверть секунды
          )
        )
      )
    {
      keyButtonList[ID].SmartTimer = 0;                                       // При срабатывании события, сбрасываем счетчик времени.
      return 1;
    }
  }
  
  
  // По умолчанию, возвращаем статус "нажатия не было" - это значит, что кнопка удерживается, но о событии уже было просигнализировано...
  return 0;
}
#endif


